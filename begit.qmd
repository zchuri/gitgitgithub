---
title: "Be Git"
---

Main features of Git:

-   Track changes (Version Control)
-   Branching and merging
-   Stashing
    -   Temporal storing changes while working on a different feature or priority task. You can later retrieve and apply those changes to your current working environment.
-   Collaboration and teamwork (enhanced through GitHub).

How Does Git Work?

-   "Unlike many version control systems, Git works with snapshots rather than differences. This means that instead of tracking the difference between two versions of a file, Git captures a complete snapshot of the project’s current state." (Tsitoara, 2024)
-   The main feature of Git is its “three states” system, which consists of the working directory (modify), the staging area (add), and the git directory (commit).

The git directory serves as the database where the project’s complete history is stored, and GitHub fits for that.

## First of all: get Git!

-   OS: <https://git-scm.com/install/>
-   Initial config:

``` bash
git config --global user.name "Your name"
git config --global user.email "your@email"
```
<!--
git config --global credential.helper store
Tip: you may use your GitHub's no-reply email (recommended for privacy).
-->

Wait a minute... it's your first time using Bash... are you panicking?... don't worry, it's quite usual... here some tips:<br> <https://linuxconfig.org/bash-scripting-tutorial-for-beginners><br> <https://www.geeksforgeeks.org/linux-unix/bash-scripting-introduction-to-bash-and-bash-scripting/><br> Super tip: the tabulator is going to became a good friend!

## First commands:

Change directory with `cd` then:

``` bash
# Local copy from the server's directory
git clone https://github.com/zchuri/ejemplo123.git
# Move into that directory
cd ejemplo123/
# Check the status
git status
```

```         
On branch main
Your branch is up to date with 'origin/main'.
```

Make a small change. Then:

``` bash
# Check the status
git status
```

```         
On branch main
Your branch is up to date with 'origin/main'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    example text.txt

nothing added to commit but untracked files present (use "git add" to track)
```

Untracked changes, then use `git add file1 file2 file3`:

``` bash
# Add file
git add 'example text.txt'

#git add file.txt          # Add specific file
#git add .                 # Add all changes

# Check the status
git status
```

```         
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    new file:   example text.txt
```

## Commit arise

A `git commit` is a permanent, versioned *snapshot* of a project's entire codebase at a specific point in time, accompanied by metadata including the author's identity (who), timestamp (when), and a descriptive message (what/why) documenting the changes made.

``` bash
# Commit
git commit -m "Adding example text file"

# Commit without -m (opens editor)
# git commit --amend -m "Better message"
```

```         
[main 04cdef8] Adding example text file
 1 file changed, 1 insertion(+)
 create mode 100644 example text.txt
```

Commit anatomy:

```         
[Commit Hash: a1b2c3d]
├── Author: Your Name <email@example.com>
├── Date:   Thu Jan 1 12:00:00 2024
├── Message: "Add user login functionality"
└── Snapshot: All files at that moment
```

Some suggestions for clear/efficient messages:

```         
feat: Add user authentication
fix: Resolve login page crash
docs: Update installation instructions
style: Format code with prettier
refactor: Simplify data processing
test: Add unit tests for API
```

Some warnings about not clear messages:

```         
fix
stuff
updated
blablabla
```

You may be tired, you may be bored, you may be distracted when writting the messages... but keep in mind who's going to read that message (including your future you).

Overview:

```         
# Working Directory      Staging Area          Commit
# (untracked/modified)   (git add)            (git commit)
┌─────────────────┐     ┌────────────┐     ┌────────────┐
│ file1.txt       │────▶│ file1.txt  │────▶│ SNAPSHOT   │
│ file2.txt       │     │            │     │ of staged  │
│ file3.txt       │     │            │     │ files      │
└─────────────────┘     └────────────┘     └────────────┘
```

How to see commits:

``` bash
# Commit history
git log                 # Full history
git log --oneline       # Compact view
git log --graph         # Visual branch history
git log -p              # Show changes in each commit

# Specific commits
git show 04cdef8        # Specific commit
git show 8ea90d3        # Specific commit
```

## Navigate between versions

The `git checkout` command enables navigation between different states within a Git repository, allowing developers to switch between branches, restore files from previous commits, or temporarily examine historical versions of the codebase without altering the current working state. This command serves as the primary mechanism for traversing the multidimensional timeline of a project's development history.

Usage:

``` bash
# Switch to an existing branch
git checkout branch-name
# Create and switch to new branch
git checkout -b new-branch-name

# Restore file from last commit
git checkout -- filename.txt
# Restore file from specific commit
git checkout COMMIT-HASH -- filename.txt
# Temporarily view project at specific commit
git checkout COMMIT-HASH
```

Example:

``` bash
# Add some text with your editor
gnome-text-editor 'example text.txt' 
git status

On branch main
Your branch is ahead of 'origin/main' by 1 commit.
  (use "git push" to publish your local commits)

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   example text.txt

no changes added to commit (use "git add" and/or "git commit -a")

# Add and commit
git add .
git commit -m 'New line for example file'
[main 90a2150] New line for example file
 1 file changed, 1 insertion(+)

git status
On branch main
Your branch is ahead of 'origin/main' by 2 commits.
  (use "git push" to publish your local commits)

# Explore the commits' hash
git log --oneline

git checkout 9fd5c2b
Note: switching to '9fd5c2b'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 9fd5c2b Merge pull request #1 from zchuri/histobranch

# Return to the main
git checkout main
```

Warning: check out does not work or any other commit if your working directory isn't clean.

`git checkout` alternatives:

``` bash
# For branch operations
git switch branch-name
git switch -c new-branch
# For file operations
git restore filename.txt
```

If you maybe have second thoughts... this is your command: `git revert`

``` bash
# Revert last commit
git revert 90a2150
# Check history changes
git log --oneline       # Compact view
# Check file changes
gnome-text-editor 'example text.txt'
```

What if you have other kind of second thoughts... don't worry, git has what you want:

-   Edit your last commit: `git commit --amend`

``` bash
# Change commit message
git commit --amend -m "New commit message"

# Add forgotten files to last commit
git add forgotten-file.txt
git commit --amend --no-edit  # Keep same message

# Change both message and content
git add fixed-file.txt
git commit --amend -m "Fix: Correct calculation logic"
```

-   Undo One or More Commits: `git reset`

```bash
# Soft reset: undo commit, keep changes STAGED
git reset --soft HEAD~1

# Mixed reset (default): undo commit, keep changes UNSTAGED
git reset HEAD~1
git reset --mixed HEAD~1  # Same as above

# Hard reset: COMPLETELY delete commit and changes
git reset --hard HEAD~1  # Careful!
```

Tip: `HEAD~1` stands for the previous commit, `HEAD` stands for the current one.

And remember:

-   Only --amend the last commit
-   Use reset to undo/remove commits
-   Never --amend or reset --hard on pushed commits (unless you're alone on the branch)
-   Use revert for pushed commits to maintain history

One last thing, let's synchronize these commits to the remote server. In the next section we will go deeper into remote and sychonization procedures.

```bash
git status

On branch main
Your branch is ahead of 'origin/main' by 1 commit. (use "git push" to publish your local commits)
nothing to commit, working tree clean

git push     # Send local commits to remote
git status
```

Well done! Yes, maybe too much commands for now, but let's move to the next challenge: work with REMOTE REPOS!!!

<center>![](images/gitful.jpg){width="50%"}<br> [Source: https://imgflip.com/i/ai3qx9]{style="font-size: 50%;"}</center>
