[
  {
    "objectID": "tutorial.html",
    "href": "tutorial.html",
    "title": "Git/GitHub Tutorial",
    "section": "",
    "text": "Go to github.com\nSign up for free"
  },
  {
    "objectID": "tutorial.html#getting-started-with-github",
    "href": "tutorial.html#getting-started-with-github",
    "title": "Git/GitHub Tutorial",
    "section": "",
    "text": "Go to github.com\nSign up for free"
  },
  {
    "objectID": "tutorial.html#prepare-for-github",
    "href": "tutorial.html#prepare-for-github",
    "title": "Git/GitHub Tutorial",
    "section": "3. Prepare for GitHub",
    "text": "3. Prepare for GitHub\n\nCreate .gitignore file:"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "gitgitgithub",
    "section": "",
    "text": "This tutorial will help you master GitHub for data science projects.\nMini-survey: https://forms.gle/VU6QLeoZqefbybKk6\n\n\n\nGit basics\nGitHub’s repositories management\nCollaboration workflows"
  },
  {
    "objectID": "index.html#learn-github-with-quarto",
    "href": "index.html#learn-github-with-quarto",
    "title": "gitgitgithub",
    "section": "",
    "text": "This tutorial will help you master GitHub for data science projects.\nMini-survey: https://forms.gle/VU6QLeoZqefbybKk6\n\n\n\nGit basics\nGitHub’s repositories management\nCollaboration workflows"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "About git/github",
    "section": "",
    "text": "Version control\n“Version control is the software engineering practice of controlling, organizing, and tracking different versions in history of computer files – primarily source code text files, but generally any type of file. (…) Version control includes options to view old versions and to revert a file to a previous version.” (Wikipedia, 2026 Jan)\nWhy this is so important? Because it can solve (or mitigate) several common problems when coding, for instance: overwriting a script or pipeline, needing to go back to a previous version, collaborating with others, tracking who what and when changes.\nAfter this tutorial you will see that version control is much more effective than:\n\nManual copies: document_v1.txt, document_v2_final.txt, document_v2_final_really.txt\nCommenting out code: leaving old code “just in case”\nPhysical notebooks\nShared network drives: the infamous “Final_FINAL.zip”\n\nInitially version control was addressed as a client-server approach (centralized), however the distributed version control systems are much flexible and it follows a peer-to-peer approach. That is, “the complete codebase, including its full history, is mirrored on every developer’s computer. Compared to centralized version control, this enables automatic management branching and merging, speeds up most operations (except pushing and fetching), improves the ability to work offline, and does not rely on a single location for backups. Git, the world’s most popular version control system, is a distributed version control system.” (Wikipedia, 2026 Jan)\n\n\nGit\n\nIt was initially developed by Linus Torvalds after the free license for BitKeeper was revoked for Linux. Git aims:\n\nspeed\ndata integrity\nnon-linear workflows (e.g., parallel branches running on different computers)\n\n“Git maintains a local copy of the entire repository, also known as the repo, with history and version-tracking abilities, independent of network access or a central server. A repository is stored on each computer in a standard directory with additional, hidden files to provide version control capabilities. Git provides features to synchronize changes between repositories that share history; for asynchronous collaboration, this extends to repositories on remote machines. Although all repositories (with the same history) are peers, developers often use a central server to host a repository to hold an integrated copy.” (Wikipedia, 2026 Jan)\n\n\nGitHub\n\nGit has some limitations to collaborate online. For example: repos’ maintainers receive contributions (patches) mainly through email, merging depends on the maintainers, limited permission management, etc. Github is a software development platform that sits on top of Git, adding new features, such as:\n\nFork & Pull Request model: lowered barrier to contribution\nWeb-based interface: made Git accessible\nSocial features: stars, followers, trending repos\nIssue tracking & Wikis: all-in-one project management\nGitHub Pages: free hosting for documentation/projects\n\nThe impact:\n\n2008: GitHub launches\n2012: 2.1 million repositories\n2015: 10 million repositories\n2018: Microsoft acquires GitHub for $7.5B\nToday: 100+ million developers, 420+ million repositories"
  },
  {
    "objectID": "github.html",
    "href": "github.html",
    "title": "GitHub",
    "section": "",
    "text": "Although Git precedes GitHub, it may be more useful to start with GitHub because is more user-friendly for beginners.\n\n\nFirst of all, you will need a github account.\n\nGo to github.com\nSign up for free\n\nFor academic purposes, GitHub offers additional features (https://github.com/education).\nExplore the dashboard and your github.com/yourusername site. Explore also the site of someone else.\n\n\n\nThis is an empty repository:\n Nevertheless, I suggest you to add some features from the begining. Relevant features to take into account:\n\nName: incompatibilities… but names are very important\nDescription/README\nLicence: depending on the context it may be really important.\n\nhttps://choosealicense.com/\nhttps://choosealicense.com/appendix/\n\n\n\n\n\nLet’s add a bit of code: https://r4ds.had.co.nz/ https://github.com/BrainMapINB\n\nUpload it through the repo’s uploader. Limits: up to 100 files at once; files &lt; 25Mb. And don’t forguet the licence.\nAlways follow this basic steps: add -&gt; commit -&gt; push\nCheck the commit.\n\n\n\nAdd new code to that file. And upload again. Check the commit info.\nEdit some code in that file. And upload again. Check the commit info. Tip: https://r-graph-gallery.com\nYou may also check the history of the “main”. You may view the entire previous version through the “…View file” option.\nAnother option would be to create a new branch based on a previous commit. Branches aim alternative or experimental pathways.\n\n\n Source: https://pdh11.blogspot.com/2013/09/a-git-workflow-at-ei.html\n\n\n\nMerging a branch into the main branch is possible through “Compare & pull request”. Rebasing instead of merging, will imply discarding the changes added into the main branch after the aforementioned branch.\n\n\nIn general, the GitHub web interface face many limitations and it is very inefficient when considering multiple files. Let’s move to integrate the repository with Git commands."
  },
  {
    "objectID": "github.html#getting-started-with-github",
    "href": "github.html#getting-started-with-github",
    "title": "GitHub",
    "section": "",
    "text": "Although Git precedes GitHub, it may be more useful to start with GitHub because is more user-friendly for beginners.\n\n\nFirst of all, you will need a github account.\n\nGo to github.com\nSign up for free\n\nFor academic purposes, GitHub offers additional features (https://github.com/education).\nExplore the dashboard and your github.com/yourusername site. Explore also the site of someone else.\n\n\n\nThis is an empty repository:\n Nevertheless, I suggest you to add some features from the begining. Relevant features to take into account:\n\nName: incompatibilities… but names are very important\nDescription/README\nLicence: depending on the context it may be really important.\n\nhttps://choosealicense.com/\nhttps://choosealicense.com/appendix/\n\n\n\n\n\nLet’s add a bit of code: https://r4ds.had.co.nz/ https://github.com/BrainMapINB\n\nUpload it through the repo’s uploader. Limits: up to 100 files at once; files &lt; 25Mb. And don’t forguet the licence.\nAlways follow this basic steps: add -&gt; commit -&gt; push\nCheck the commit.\n\n\n\nAdd new code to that file. And upload again. Check the commit info.\nEdit some code in that file. And upload again. Check the commit info. Tip: https://r-graph-gallery.com\nYou may also check the history of the “main”. You may view the entire previous version through the “…View file” option.\nAnother option would be to create a new branch based on a previous commit. Branches aim alternative or experimental pathways.\n\n\n Source: https://pdh11.blogspot.com/2013/09/a-git-workflow-at-ei.html\n\n\n\nMerging a branch into the main branch is possible through “Compare & pull request”. Rebasing instead of merging, will imply discarding the changes added into the main branch after the aforementioned branch.\n\n\nIn general, the GitHub web interface face many limitations and it is very inefficient when considering multiple files. Let’s move to integrate the repository with Git commands."
  },
  {
    "objectID": "github.html#prepare-for-github",
    "href": "github.html#prepare-for-github",
    "title": "GitHub",
    "section": "3. Prepare for GitHub",
    "text": "3. Prepare for GitHub\n\nCreate .gitignore file:"
  },
  {
    "objectID": "index.html#scientific-context",
    "href": "index.html#scientific-context",
    "title": "gitgitgithub",
    "section": "Scientific context",
    "text": "Scientific context\n\nSquare one: “Hackaton” https://doi.org/10.1186/s13742-016-0121-x\nR package: https://doi.org/10.32614/CRAN.package.NBR https://doi.org/10.7554/eLife.55081\nAnother academic “hackaton”: https://neurohackademy.org/\n\n“We can do great things with coding” (Ariel Rokem)\nGreat overview: https://neurohackademy.org/course/from-interactive-exploration-to-reproducible-data-science-jupyter-binder-travis-and-friends-2/"
  },
  {
    "objectID": "begit.html",
    "href": "begit.html",
    "title": "Be Git",
    "section": "",
    "text": "Main features of Git:\nHow Does Git Work?\nThe git directory serves as the database where the project’s complete history is stored, and GitHub fits for that."
  },
  {
    "objectID": "begit.html#getting-started-with-github",
    "href": "begit.html#getting-started-with-github",
    "title": "Be Git",
    "section": "",
    "text": "Go to github.com\nSign up for free"
  },
  {
    "objectID": "begit.html#prepare-for-github",
    "href": "begit.html#prepare-for-github",
    "title": "Be Git",
    "section": "3. Prepare for GitHub",
    "text": "3. Prepare for GitHub\n\nCreate .gitignore file:"
  },
  {
    "objectID": "begit.html#first-of-all-get-git",
    "href": "begit.html#first-of-all-get-git",
    "title": "Be Git",
    "section": "First of all: get Git!",
    "text": "First of all: get Git!\n\nOS: https://git-scm.com/install/\nInitial config:\n\ngit config --global user.name \"Your name\"\ngit config --global user.email \"your@email\"\n\nWait a minute… it’s your first time using Bash… are you panicking?… don’t worry, it’s quite usual… here some tips: https://linuxconfig.org/bash-scripting-tutorial-for-beginners https://www.geeksforgeeks.org/linux-unix/bash-scripting-introduction-to-bash-and-bash-scripting/ Super tip: the tabulator is going to became a good friend!"
  },
  {
    "objectID": "begit.html#first-commands",
    "href": "begit.html#first-commands",
    "title": "Be Git",
    "section": "First commands:",
    "text": "First commands:\nChange directory with cd then:\n# Local copy from the server's directory\ngit clone https://github.com/zchuri/ejemplo123.git\n# Move into that directory\ncd ejemplo123/\n# Check the status\ngit status\nOn branch main\nYour branch is up to date with 'origin/main'.\nMake a small change. Then:\n# Check the status\ngit status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n    example text.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nUntracked changes, then use git add file1 file2 file3:\n# Add file\ngit add 'example text.txt'\n\n#git add file.txt          # Add specific file\n#git add .                 # Add all changes\n\n# Check the status\ngit status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n    new file:   example text.txt"
  },
  {
    "objectID": "begit.html#commit-arise",
    "href": "begit.html#commit-arise",
    "title": "Be Git",
    "section": "Commit arise",
    "text": "Commit arise\nA git commit is a permanent, versioned snapshot of a project’s entire codebase at a specific point in time, accompanied by metadata including the author’s identity (who), timestamp (when), and a descriptive message (what/why) documenting the changes made.\n# Commit\ngit commit -m \"Adding example text file\"\n\n# Commit without -m (opens editor)\n# git commit --amend -m \"Better message\"\n[main 04cdef8] Adding example text file\n 1 file changed, 1 insertion(+)\n create mode 100644 example text.txt\nCommit anatomy:\n[Commit Hash: a1b2c3d]\n├── Author: Your Name &lt;email@example.com&gt;\n├── Date:   Thu Jan 1 12:00:00 2024\n├── Message: \"Add user login functionality\"\n└── Snapshot: All files at that moment\nSome suggestions for clear/efficient messages:\nfeat: Add user authentication\nfix: Resolve login page crash\ndocs: Update installation instructions\nstyle: Format code with prettier\nrefactor: Simplify data processing\ntest: Add unit tests for API\nSome warnings about not clear messages:\nfix\nstuff\nupdated\nblablabla\nYou may be tired, you may be bored, you may be distracted when writting the messages… but keep in mind who’s going to read that message (including your future you).\nOverview:\n# Working Directory      Staging Area          Commit\n# (untracked/modified)   (git add)            (git commit)\n┌─────────────────┐     ┌────────────┐     ┌────────────┐\n│ file1.txt       │────▶│ file1.txt  │────▶│ SNAPSHOT   │\n│ file2.txt       │     │            │     │ of staged  │\n│ file3.txt       │     │            │     │ files      │\n└─────────────────┘     └────────────┘     └────────────┘\nHow to see commits:\n# Commit history\ngit log                 # Full history\ngit log --oneline       # Compact view\ngit log --graph         # Visual branch history\ngit log -p              # Show changes in each commit\n\n# Specific commits\ngit show 04cdef8        # Specific commit\ngit show 8ea90d3        # Specific commit"
  },
  {
    "objectID": "begit.html#navigate-between-versions",
    "href": "begit.html#navigate-between-versions",
    "title": "Be Git",
    "section": "Navigate between versions",
    "text": "Navigate between versions\nThe git checkout command enables navigation between different states within a Git repository, allowing developers to switch between branches, restore files from previous commits, or temporarily examine historical versions of the codebase without altering the current working state. This command serves as the primary mechanism for traversing the multidimensional timeline of a project’s development history.\nUsage:\n# Switch to an existing branch\ngit checkout branch-name\n# Create and switch to new branch\ngit checkout -b new-branch-name\n\n# Restore file from last commit\ngit checkout -- filename.txt\n# Restore file from specific commit\ngit checkout COMMIT-HASH -- filename.txt\n# Temporarily view project at specific commit\ngit checkout COMMIT-HASH\nExample:\n# Add some text with your editor\ngnome-text-editor 'example text.txt' \ngit status\n\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n    modified:   example text.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n# Add and commit\ngit add .\ngit commit -m 'New line for example file'\n[main 90a2150] New line for example file\n 1 file changed, 1 insertion(+)\n\ngit status\nOn branch main\nYour branch is ahead of 'origin/main' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\n# Explore the commits' hash\ngit log --oneline\n\ngit checkout 9fd5c2b\nNote: switching to '9fd5c2b'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by switching back to a branch.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -c with the switch command. Example:\n\n  git switch -c &lt;new-branch-name&gt;\n\nOr undo this operation with:\n\n  git switch -\n\nTurn off this advice by setting config variable advice.detachedHead to false\n\nHEAD is now at 9fd5c2b Merge pull request #1 from zchuri/histobranch\n\n# Return to the main\ngit checkout main\nWarning: check out does not work or any other commit if your working directory isn’t clean.\ngit checkout alternatives:\n# For branch operations\ngit switch branch-name\ngit switch -c new-branch\n# For file operations\ngit restore filename.txt\nIf you maybe have second thoughts… this is your command: git revert\n# Revert last commit\ngit revert 90a2150\n# Check history changes\ngit log --oneline       # Compact view\n# Check file changes\ngnome-text-editor 'example text.txt'\nWhat if you have other kind of second thoughts… don’t worry, git has what you want:\n\nEdit your last commit: git commit --amend\n\n# Change commit message\ngit commit --amend -m \"New commit message\"\n\n# Add forgotten files to last commit\ngit add forgotten-file.txt\ngit commit --amend --no-edit  # Keep same message\n\n# Change both message and content\ngit add fixed-file.txt\ngit commit --amend -m \"Fix: Correct calculation logic\"\n\nUndo One or More Commits: git reset\n\n# Soft reset: undo commit, keep changes STAGED\ngit reset --soft HEAD~1\n\n# Mixed reset (default): undo commit, keep changes UNSTAGED\ngit reset HEAD~1\ngit reset --mixed HEAD~1  # Same as above\n\n# Hard reset: COMPLETELY delete commit and changes\ngit reset --hard HEAD~1  # Careful!\nTip: HEAD~1 stands for the previous commit, HEAD stands for the current one.\nAnd remember:\n\nOnly –amend the last commit\nUse reset to undo/remove commits\nNever –amend or reset –hard on pushed commits (unless you’re alone on the branch)\nUse revert for pushed commits to maintain history\n\nOne last thing, let’s synchronize these commits to the remote server. In the next section we will go deeper into remote and sychonization procedures.\ngit status\n\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit. (use \"git push\" to publish your local commits)\nnothing to commit, working tree clean\n\ngit push     # Send local commits to remote\ngit status\nWell done! Yes, maybe too much commands for now, but let’s move to the next challenge: work with REMOTE REPOS!!!\n\n Source: https://imgflip.com/i/ai3qx9"
  },
  {
    "objectID": "gogit.html",
    "href": "gogit.html",
    "title": "Beyond local",
    "section": "",
    "text": "Remote repositories are copies of your Git repository stored on servers, enabling collaboration across teams, locations, and time zones. Unlike centralized systems with a single “source of truth,” Git’s distributed nature means every developer has a complete copy of the repository history, with remote servers acting as synchronization points.\nOverview:\nWhile Git excels at local version control, its capabilities are enhanced when connected to remote repositories. Github fits perfectly as a server. GitHub transforms Git’s technical remote capabilities into an intuitive, social platform where developers can seamlessly share code, review changes, and collaborate at scale.\nGitHub is a great tool for open source projects, but also it allows for personal use with private repositories. Private repos are not only personal, they may have collaborators (of course, invited by the master’s). Furthermore, even if you conceive an open source project, you may keep it private initially and eventually you may deploy it public."
  },
  {
    "objectID": "gogit.html#first-of-all-get-git",
    "href": "gogit.html#first-of-all-get-git",
    "title": "Go Git",
    "section": "First of all: get Git!",
    "text": "First of all: get Git!\n\nOS: https://git-scm.com/install/\nInitial config:\n\ngit config --global user.name \"Your name\"\ngit config --global user.email \"your@email\"\ngit config --global credential.helper store\nTip: you may use your GitHub’s no-reply email (recommended for privacy).\nWait a minute… it’s your first time using Bash… are you panicking?… don’t worry, it’s quite usual… here some tips: https://linuxconfig.org/bash-scripting-tutorial-for-beginners https://www.geeksforgeeks.org/linux-unix/bash-scripting-introduction-to-bash-and-bash-scripting/ Super tip: the tabulator is going to became a good friend!"
  },
  {
    "objectID": "gogit.html#first-commands",
    "href": "gogit.html#first-commands",
    "title": "Go Git",
    "section": "First commands:",
    "text": "First commands:\nChange directory with cd then:\n# Local copy from the server's directory\ngit clone https://github.com/zchuri/ejemplo123.git\n# Move into that directory\ncd ejemplo123/\n# Check the status\ngit status\nOn branch main\nYour branch is up to date with 'origin/main'.\nMake a small change. Then:\n# Check the status\ngit status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n    example text.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nUntracked changes, then use git add file1 file2 file3:\n# Add file\ngit add 'example text.txt'\n\n#git add file.txt          # Add specific file\n#git add .                 # Add all changes\n\n# Check the status\ngit status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n    new file:   example text.txt"
  },
  {
    "objectID": "gogit.html#commit-arise",
    "href": "gogit.html#commit-arise",
    "title": "Go-Git",
    "section": "Commit arise",
    "text": "Commit arise\nA git commit is a permanent, versioned snapshot of a project’s entire codebase at a specific point in time, accompanied by metadata including the author’s identity (who), timestamp (when), and a descriptive message (what/why) documenting the changes made.\n# Commit\ngit commit -m \"Adding example text file\"\n\n# Commit without -m (opens editor)\n# git commit --amend -m \"Better message\"\n[main 04cdef8] Adding example text file\n 1 file changed, 1 insertion(+)\n create mode 100644 example text.txt\nCommit anatomy:\n[Commit Hash: a1b2c3d]\n├── Author: Your Name &lt;email@example.com&gt;\n├── Date:   Thu Jan 1 12:00:00 2024\n├── Message: \"Add user login functionality\"\n└── Snapshot: All files at that moment\nSome suggestions for clear/efficient messages:\nfeat: Add user authentication\nfix: Resolve login page crash\ndocs: Update installation instructions\nstyle: Format code with prettier\nrefactor: Simplify data processing\ntest: Add unit tests for API\nSome warnings about not clear messages:\nfix\nstuff\nupdated\nblablabla\nYou may be tired, you may be bored, you may be distracted when writting the messages… but keep in mind who’s going to read that message (including your future you).\nOverview:\n# Working Directory      Staging Area          Commit\n# (untracked/modified)   (git add)            (git commit)\n┌─────────────────┐     ┌────────────┐     ┌────────────┐\n│ file1.txt       │────▶│ file1.txt  │────▶│ SNAPSHOT   │\n│ file2.txt       │     │            │     │ of staged  │\n│ file3.txt       │     │            │     │ files      │\n└─────────────────┘     └────────────┘     └────────────┘\nHow to see commits:\n# Commit history\ngit log                 # Full history\ngit log --oneline       # Compact view\ngit log --graph         # Visual branch history\ngit log -p              # Show changes in each commit\n\n# Specific commits\ngit show 04cdef8        # Specific commit\ngit show 8ea90d3        # Specific commit"
  },
  {
    "objectID": "gogit.html#navigate-between-versions",
    "href": "gogit.html#navigate-between-versions",
    "title": "Go-Git",
    "section": "Navigate between versions",
    "text": "Navigate between versions\nThe git checkout command enables navigation between different states within a Git repository, allowing developers to switch between branches, restore files from previous commits, or temporarily examine historical versions of the codebase without altering the current working state. This command serves as the primary mechanism for traversing the multidimensional timeline of a project’s development history.\nUsage:\n# Switch to an existing branch\ngit checkout branch-name\n# Create and switch to new branch\ngit checkout -b new-branch-name\n\n# Restore file from last commit\ngit checkout -- filename.txt\n# Restore file from specific commit\ngit checkout COMMIT-HASH -- filename.txt\n# Temporarily view project at specific commit\ngit checkout COMMIT-HASH\nExample:\n# Add some text with your editor\ngnome-text-editor 'example text.txt' \ngit status\n\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n    modified:   example text.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n# Add and commit\ngit add .\ngit commit -m 'New line for example file'\n[main 90a2150] New line for example file\n 1 file changed, 1 insertion(+)\n\ngit status\nOn branch main\nYour branch is ahead of 'origin/main' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\n# Explore the commits' hash\ngit log --oneline\n\ngit checkout 9fd5c2b\nNote: switching to '9fd5c2b'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by switching back to a branch.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -c with the switch command. Example:\n\n  git switch -c &lt;new-branch-name&gt;\n\nOr undo this operation with:\n\n  git switch -\n\nTurn off this advice by setting config variable advice.detachedHead to false\n\nHEAD is now at 9fd5c2b Merge pull request #1 from zchuri/histobranch\n\n# Return to the main\ngit checkout main\nWarning: check out does not work or any other commit if your working directory isn’t clean.\ngit checkout alternatives:\n# For branch operations\ngit switch branch-name\ngit switch -c new-branch\n# For file operations\ngit restore filename.txt\nIf you maybe have second thoughts… this is your command: git revert\n# Revert last commit\ngit revert 90a2150\n# Check history changes\ngit log --oneline       # Compact view\n# Check file changes\ngnome-text-editor 'example text.txt'\nWhat if you have other kind of second thoughts… don’t worry, git has what you want:\n\nEdit your last commit: git commit --amend\n\n# Change commit message\ngit commit --amend -m \"New commit message\"\n\n# Add forgotten files to last commit\ngit add forgotten-file.txt\ngit commit --amend --no-edit  # Keep same message\n\n# Change both message and content\ngit add fixed-file.txt\ngit commit --amend -m \"Fix: Correct calculation logic\"\n\nUndo One or More Commits: git reset\n\n# Soft reset: undo commit, keep changes STAGED\ngit reset --soft HEAD~1\n\n# Mixed reset (default): undo commit, keep changes UNSTAGED\ngit reset HEAD~1\ngit reset --mixed HEAD~1  # Same as above\n\n# Hard reset: COMPLETELY delete commit and changes\ngit reset --hard HEAD~1  # Careful!\nTip: HEAD~1 stands for the previous commit, HEAD stands for the current one.\nAnd remember:\n\nOnly –amend the last commit\nUse reset to undo/remove commits\nNever –amend or reset –hard on pushed commits (unless you’re alone on the branch)\nUse revert for pushed commits to maintain history\n\ngit status On branch main Your branch is ahead of ‘origin/main’ by 1 commit. (use “git push” to publish your local commits)\nnothing to commit, working tree clean\ngit log git branch new-branch-name git checkout new-branch-name # switch between branches git checkout main git pull origin main # origin stands for the remote server git merge git push"
  },
  {
    "objectID": "gogit.html#issues",
    "href": "gogit.html#issues",
    "title": "Go-Git",
    "section": "Issues",
    "text": "Issues\nNow we are going to focus on GitHub’s issues:\nGo to GitHub’s repo, then “Issues” (next to Code), then “New Issue”. Then you may specify any sort of issue, and you can even tag other users with the @ symbol. In fact, you may directly assign an issue to another user. Labeling the issues is also possible.\nMake a small change. Then:\n# Check the status\ngit status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n    example text.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nUntracked changes, then use git add file1 file2 file3:\n# Add file\ngit add 'example text.txt'\n\n#git add file.txt          # Add specific file\n#git add .                 # Add all changes\n\n# Check the status\ngit status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n    new file:   example text.txt"
  },
  {
    "objectID": "gogit.html#practice",
    "href": "gogit.html#practice",
    "title": "Beyond local",
    "section": "Practice",
    "text": "Practice\n“I hear it, I forget; I see it, I remember; I do it, I understand.”\nLet’s practice a little bit:\n# Create a branch\ngit branch &lt;name&gt;\n\n# Switch to Another Branch\ngit branch        # Branchs list\ngit checkout &lt;name&gt;\n\n# Delete a branch\ngit branch -d &lt;name&gt;\n\n# Merge brach\ngit merge &lt;name&gt;\n\n# Pushing a Branch to Remote\ngit push &lt;remote_name&gt; &lt;branch_name&gt;"
  },
  {
    "objectID": "gogit.html#common-pitfalls",
    "href": "gogit.html#common-pitfalls",
    "title": "Beyond local",
    "section": "Common pitfalls",
    "text": "Common pitfalls\n# Problem: meant to create feature branch but committed to main\ngit add .\ngit commit -m \"New feature\"  # Oops!\n# Solution: Create new branch with the commit\ngit branch feature/new-feature\n# Reset main back\ngit checkout main\ngit reset --hard HEAD~1  # Delete commit from main\n\n\n# Problem: start working on outdated code, then\ngit push origin feature  # REJECTED - behind remote\n# Solution: Always pull first\ngit checkout main\ngit pull origin main\ngit checkout -b feature/new-work\n# If already happened:\ngit pull --rebase origin main\n# Resolve conflicts, then push\n\n\n#Problem: Working on main instead of feature branch\n# Made multiple commits on wrong branch\n# Solution\n# 1. Create new branch from current state\ngit branch feature/work-in-progress\n\n# 2. Reset main back\ngit checkout main\ngit reset --hard origin/main  # Back to remote state\n\n# 3. Cherry-pick commits if needed\ngit checkout feature/work-in-progress\ngit log --oneline  # Get commit hashes\ngit checkout main\ngit cherry-pick abc123 def456"
  },
  {
    "objectID": "gogit.html#pull-request",
    "href": "gogit.html#pull-request",
    "title": "Beyond local",
    "section": "Pull request",
    "text": "Pull request\ngit pull is a local Git command that fetches updates from a remote repository and immediately merges them into your current branch, synchronizing your local work with the latest remote changes in a single operation. From a single user point of view, this is also helpful, considering you switch sessions or computers.\n# Return to the previous repo\ncd ../../ejemplo123/\ngit status\n# Pull\ngit pull\n\ngit branch experimental history git branch git checkout experimental touch expfile.txt nano expfile.txt cat expfile.txt"
  },
  {
    "objectID": "gogithub.html",
    "href": "gogithub.html",
    "title": "Go-GitHub",
    "section": "",
    "text": "Now we are going to focus on GitHub’s issues:\nGo to GitHub’s repo, then “Issues” (next to Code), then “New Issue”. Then you may specify any sort of issue, and you can even tag other users with the @ symbol. In fact, you may directly assign an issue to another user. Labeling the issues is also possible."
  },
  {
    "objectID": "gogithub.html#issues",
    "href": "gogithub.html#issues",
    "title": "Go-GitHub",
    "section": "",
    "text": "Now we are going to focus on GitHub’s issues:\nGo to GitHub’s repo, then “Issues” (next to Code), then “New Issue”. Then you may specify any sort of issue, and you can even tag other users with the @ symbol. In fact, you may directly assign an issue to another user. Labeling the issues is also possible."
  },
  {
    "objectID": "undergit.html",
    "href": "undergit.html",
    "title": "Under Git",
    "section": "",
    "text": "Shall we go private?\nLet’s create a private repo with a inner circle of collaborators.\nIf your credentials or tokens are not stored, git will ask for them.\nRefresh the GitHub’s repo and invite someone else to the stage: Settings -&gt; Collaborators\nAsk your collaborator to add something else (in the main). Then:\nThe git pull command is used to fetch and merge changes from a remote repository into your current local branch. Actions: pulls down changes made by others; merges fetched changes into your current branch; just a single command to update and integrate.\nAsk your collaborator to do something else… privately, of course. Another option to git pull is git fecth.\ngit fetch is a synchronization command that retrieves updates from a remote repository without modifying your local working files or commit history. If you want to walk more carefully into pulling remote changes, then, it’s better to fetch before you merge:\nWell, if you want to walk even more carefully between remote changes, particularly from a collaborator, ask s/he to create a branch, then you may decide to merge it or not."
  },
  {
    "objectID": "undergit.html#issues",
    "href": "undergit.html#issues",
    "title": "Under Git",
    "section": "Issues",
    "text": "Issues\nNow we are going to focus on GitHub’s issues:\nGo to GitHub’s repo, then “Issues” (next to Code), then “New Issue”. Then you may specify any sort of issue, and you can even tag other users with the @ symbol. In fact, you may directly assign an issue to another user. Labeling the issues is also possible.\n\nNice example with great tips: https://neurohackademy.org/course/tbd-4/"
  },
  {
    "objectID": "beyondgit.html",
    "href": "beyondgit.html",
    "title": "Beyond local",
    "section": "",
    "text": "Remote repositories are copies of your Git repository stored on servers, enabling collaboration across teams, locations, and time zones. Unlike centralized systems with a single “source of truth,” Git’s distributed nature means every developer has a complete copy of the repository history, with remote servers acting as synchronization points.\nOverview:\nWhile Git excels at local version control, its capabilities are enhanced when connected to remote repositories. Github fits perfectly as a server. GitHub transforms Git’s technical remote capabilities into an intuitive, social platform where developers can seamlessly share code, review changes, and collaborate at scale.\nGitHub is a great tool for open source projects, but also it allows for personal use with private repositories. Private repos are not only personal, they may have collaborators (of course, invited by the master’s). Furthermore, even if you conceive an open source project, you may keep it private initially and eventually you may deploy it public."
  },
  {
    "objectID": "beyondgit.html#practice",
    "href": "beyondgit.html#practice",
    "title": "Beyond local",
    "section": "Practice",
    "text": "Practice\n“I hear it, I forget; I see it, I remember; I do it, I understand.”\nLet’s practice a little bit:\n# Create a branch\ngit branch &lt;name&gt;\n\n# Switch to Another Branch\ngit branch        # Branchs list\ngit checkout &lt;name&gt;\n\n# Delete a branch\ngit branch -d &lt;name&gt;\n\n# Merge brach\ngit merge &lt;name&gt;\n\n# Pushing a Branch to Remote\ngit push &lt;remote_name&gt; &lt;branch_name&gt;"
  },
  {
    "objectID": "beyondgit.html#pull-request",
    "href": "beyondgit.html#pull-request",
    "title": "Beyond local",
    "section": "Pull request",
    "text": "Pull request\ngit pull is a local Git command that fetches updates from a remote repository and immediately merges them into your current branch, synchronizing your local work with the latest remote changes in a single operation. From a single user point of view, this is also helpful, considering you switch sessions or computers.\n# Return to the previous repo\ncd ../../ejemplo123/\ngit status\n# Pull\ngit pull"
  },
  {
    "objectID": "beyondgit.html#common-pitfalls",
    "href": "beyondgit.html#common-pitfalls",
    "title": "Beyond local",
    "section": "Common pitfalls",
    "text": "Common pitfalls\n# Problem: meant to create feature branch but committed to main\ngit add .\ngit commit -m \"New feature\"  # Oops!\n# Solution: Create new branch with the commit\ngit branch feature/new-feature\n# Reset main back\ngit checkout main\ngit reset --hard HEAD~1  # Delete commit from main\n\n\n# Problem: start working on outdated code, then\ngit push origin feature  # REJECTED - behind remote\n# Solution: Always pull first\ngit checkout main\ngit pull origin main\ngit checkout -b feature/new-work\n# If already happened:\ngit pull --rebase origin main\n# Resolve conflicts, then push\n\n\n#Problem: Working on main instead of feature branch\n# Made multiple commits on wrong branch\n# Solution\n# 1. Create new branch from current state\ngit branch feature/work-in-progress\n\n# 2. Reset main back\ngit checkout main\ngit reset --hard origin/main  # Back to remote state\n\n# 3. Cherry-pick commits if needed\ngit checkout feature/work-in-progress\ngit log --oneline  # Get commit hashes\ngit checkout main\ngit cherry-pick abc123 def456"
  },
  {
    "objectID": "undergit.html#common-pitfalls",
    "href": "undergit.html#common-pitfalls",
    "title": "Under Git",
    "section": "Common pitfalls",
    "text": "Common pitfalls\nOur dear collaborator have done some stuff in the main, without letting the master (aka me) know.\ngit status\nnano 'more private.txt'\ngit status\ngit add .\ngit commit -m 'beatiful text added'\nBut I am working on the main as usual. Making coding, making adding, making commits… being proud of my progress. I go home, but before let’s make a push. Let’s see…\ngit push\n\n Source: https://i.imgflip.com/4qbbg8.mp4\n\nRelax. The error says: “If you want to integrate the remote changes, use hint: ‘git pull’ before pushing again.” …among other things\ngit pull\n\n Source: https://imgflip.com/i/ai9sbm\n\nThe problem:\nREMOTE:   A ← B ← C [origin/main]\n              \\\nYOUR LOCAL:    B ← D ← E [main]\nCheck the problem:\ngit fetch origin\ngit status\n# \"Your branch and 'origin/main' have diverged\"\n\n# See what they added\ngit log --oneline HEAD..origin/main\n# See what you added\ngit log --oneline origin/main..HEAD\nSeveral option:\n\nRebase: put your changes after theirs (like adding your paragraph at the end)\nMerge: combined version (merge commit)\nDiscard: use their version if yours was just a draft.\n\n# Rebase\n\n# Step 1: Stash any uncommitted changes\ngit stash\n# Step 2: Rebase your commits on top of theirs\ngit pull --rebase origin main\n# Step 3: If conflicts occur, resolve them:\n# - Edit conflicted files\n# - Mark resolved: git add filename\n# - Continue rebase: git rebase --continue\n# Step 4: Restore stashed changes\ngit stash pop\n# Step 5: Now push\ngit push origin main\n\nBEFORE:          AFTER REBASE:\nRemote: A←B←C    Remote: A←B←C←D'←E'\nLocal:  A←B←D←E  Local:  A←B←C←D'←E'\ngit stash is a temporary storage command that saves your uncommitted changes (both staged and unstaged) and reverts your working directory to match the last commit, allowing you to switch contexts without committing incomplete work. Think of it as a “save slot” for your in-progress changes that you can restore later.\n\nMerge (Preserves Both Histories)\n\n# Step 1: Pull with merge (not rebase)\ngit pull origin main\n# Step 2: Resolve any merge conflicts\n# Edit files, then:\ngit add resolved-files\n# Step 3: Commit the merge\ngit commit -m \"Merge remote changes\"\n# Step 4: Push\ngit push origin main\n\nA←B←C [theirs]\n     \\\n      D←E [yours] ← Merge commit ← [new]\n      \n\n# Hard Reset (If You Don't Care About Your Changes)\n\n# WARNING: This discards your local commits!\ngit fetch origin\ngit reset --hard origin/main\n# Now your local matches remote exactly\n\n\nThere is always other options: create new branches, for example. And prevenetion helps as well:\n# ALWAYS do this before starting work:\ngit checkout main\ngit pull origin main\n\n# THEN create feature branch\ngit checkout -b feature/your-work\n\n# Work, commit, push your branch\ngit push -u origin feature/your-work\n\n# Merge via Pull Request (not directly to main)"
  }
]