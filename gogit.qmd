---
title: "Go Git"
---

Remote repositories are copies of your Git repository stored on *servers*, enabling collaboration across teams, locations, and time zones. Unlike centralized systems with a single "source of truth," Git's distributed nature means every developer has a complete copy of the repository history, with remote servers acting as synchronization points.

Overview:

``` bash
# Add remote repository
git remote add origin https://github.com/user/repo.git

# Send local commits to remote
git push origin main

# Get remote changes
git pull origin main

# Fetch changes without merging
git fetch origin

# Clone existing remote repository
git clone https://github.com/user/repo.git
```

While Git excels at local version control, its capabilities are enhanced when connected to remote repositories. Github fits perfectly as a *server*. GitHub transforms Git's technical remote capabilities into an intuitive, social platform where developers can seamlessly share code, review changes, and collaborate at scale.

![](images/github_activity.png){width="100%"}<br><br>

GitHub is a great tool for open source projects, but also it allows for personal use with private repositories. Private repos are not only personal, they may have collaborators (of course, invited by the master's). Furthermore, even if you conceive an open source project, you may keep it private initially and eventually you may deploy it public. 

# Remote basics

Let's review this:

``` bash
git config --global user.name "Your name"
git config --global user.email "your@email"
git config --global credential.helper store
```
Tip: you may use your GitHub's no-reply email (recommended for privacy). And let's add a classic token to connect to the server.



Wait a minute... it's your first time using Bash... are you panicking?... don't worry, it's quite usual... here some tips:<br> <https://linuxconfig.org/bash-scripting-tutorial-for-beginners><br> <https://www.geeksforgeeks.org/linux-unix/bash-scripting-introduction-to-bash-and-bash-scripting/><br> Super tip: the tabulator is going to became a good friend!

## First commands:

Change directory with `cd` then:

``` bash
# Local copy from the server's directory
git clone https://github.com/zchuri/ejemplo123.git
# Move into that directory
cd ejemplo123/
# Check the status
git status
```

```         
On branch main
Your branch is up to date with 'origin/main'.
```

Make a small change. Then:

``` bash
# Check the status
git status
```

```         
On branch main
Your branch is up to date with 'origin/main'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    example text.txt

nothing added to commit but untracked files present (use "git add" to track)
```

Untracked changes, then use `git add file1 file2 file3`:

``` bash
# Add file
git add 'example text.txt'

#git add file.txt          # Add specific file
#git add .                 # Add all changes

# Check the status
git status
```

```         
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    new file:   example text.txt
```

## Commit arise

A `git commit` is a permanent, versioned *snapshot* of a project's entire codebase at a specific point in time, accompanied by metadata including the author's identity (who), timestamp (when), and a descriptive message (what/why) documenting the changes made.

``` bash
# Commit
git commit -m "Adding example text file"

# Commit without -m (opens editor)
# git commit --amend -m "Better message"
```

```         
[main 04cdef8] Adding example text file
 1 file changed, 1 insertion(+)
 create mode 100644 example text.txt
```

Commit anatomy:

```         
[Commit Hash: a1b2c3d]
├── Author: Your Name <email@example.com>
├── Date:   Thu Jan 1 12:00:00 2024
├── Message: "Add user login functionality"
└── Snapshot: All files at that moment
```

Some suggestions for clear/efficient messages:

```         
feat: Add user authentication
fix: Resolve login page crash
docs: Update installation instructions
style: Format code with prettier
refactor: Simplify data processing
test: Add unit tests for API
```

Some warnings about not clear messages:

```         
fix
stuff
updated
blablabla
```

You may be tired, you may be bored, you may be distracted when writting the messages... but keep in mind who's going to read that message (including your future you).

Overview:

```         
# Working Directory      Staging Area          Commit
# (untracked/modified)   (git add)            (git commit)
┌─────────────────┐     ┌────────────┐     ┌────────────┐
│ file1.txt       │────▶│ file1.txt  │────▶│ SNAPSHOT   │
│ file2.txt       │     │            │     │ of staged  │
│ file3.txt       │     │            │     │ files      │
└─────────────────┘     └────────────┘     └────────────┘
```

How to see commits:

``` bash
# Commit history
git log                 # Full history
git log --oneline       # Compact view
git log --graph         # Visual branch history
git log -p              # Show changes in each commit

# Specific commits
git show 04cdef8        # Specific commit
git show 8ea90d3        # Specific commit
```

## Navigate between versions

The `git checkout` command enables navigation between different states within a Git repository, allowing developers to switch between branches, restore files from previous commits, or temporarily examine historical versions of the codebase without altering the current working state. This command serves as the primary mechanism for traversing the multidimensional timeline of a project's development history.

Usage:

``` bash
# Switch to an existing branch
git checkout branch-name
# Create and switch to new branch
git checkout -b new-branch-name

# Restore file from last commit
git checkout -- filename.txt
# Restore file from specific commit
git checkout COMMIT-HASH -- filename.txt
# Temporarily view project at specific commit
git checkout COMMIT-HASH
```

Example:

``` bash
# Add some text with your editor
gnome-text-editor 'example text.txt' 
git status

On branch main
Your branch is ahead of 'origin/main' by 1 commit.
  (use "git push" to publish your local commits)

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   example text.txt

no changes added to commit (use "git add" and/or "git commit -a")

# Add and commit
git add .
git commit -m 'New line for example file'
[main 90a2150] New line for example file
 1 file changed, 1 insertion(+)

git status
On branch main
Your branch is ahead of 'origin/main' by 2 commits.
  (use "git push" to publish your local commits)

# Explore the commits' hash
git log --oneline

git checkout 9fd5c2b
Note: switching to '9fd5c2b'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 9fd5c2b Merge pull request #1 from zchuri/histobranch

# Return to the main
git checkout main
```

Warning: check out does not work or any other commit if your working directory isn't clean.

`git checkout` alternatives:

``` bash
# For branch operations
git switch branch-name
git switch -c new-branch
# For file operations
git restore filename.txt
```

If you maybe have second thoughts... this is your command: `git revert`

``` bash
# Revert last commit
git revert 90a2150
# Check history changes
git log --oneline       # Compact view
# Check file changes
gnome-text-editor 'example text.txt'
```

What if you have other kind of second thoughts... don't worry, git has what you want:

-   Edit your last commit: `git commit --amend`

``` bash
# Change commit message
git commit --amend -m "New commit message"

# Add forgotten files to last commit
git add forgotten-file.txt
git commit --amend --no-edit  # Keep same message

# Change both message and content
git add fixed-file.txt
git commit --amend -m "Fix: Correct calculation logic"
```

-   Undo One or More Commits: `git reset`

``` bash
# Soft reset: undo commit, keep changes STAGED
git reset --soft HEAD~1

# Mixed reset (default): undo commit, keep changes UNSTAGED
git reset HEAD~1
git reset --mixed HEAD~1  # Same as above

# Hard reset: COMPLETELY delete commit and changes
git reset --hard HEAD~1  # Careful!
```

Tip: `HEAD~1` stands for the previous commit, `HEAD` stands for the current one.

And remember:

-   Only --amend the last commit
-   Use reset to undo/remove commits
-   Never --amend or reset --hard on pushed commits (unless you're alone on the branch)
-   Use revert for pushed commits to maintain history

git status On branch main Your branch is ahead of 'origin/main' by 1 commit. (use "git push" to publish your local commits)

nothing to commit, working tree clean

git log git branch new-branch-name git checkout new-branch-name \# switch between branches git checkout main git pull origin main \# origin stands for the remote server git merge git push
